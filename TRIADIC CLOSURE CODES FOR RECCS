##Triadic closure: The tendency of nodes orentities in a network who share relations to
become connected themselves
USE TRIADIC CLUOSURE TO MAKE RECCS BASED ON LOCATION OF USERS AND SIMILARITY OF TASTES

****RECC#1 BASED ON USER LOCATION: SIMPLE GRAPH, DISTANCE AS WEIGHTS. CLOSENESS CENTRALITY.***
#Use this to make recommendations based on location (Closeness centrality, weights determined by distance)

#Make a simple graph
#code G as graph
G = nx.Graph()

#add edges to our graph
G.add_edge('A','B')

# Keep on adding edges like so...
G.add_edge('C','D')

#Can also add numbers as edges
G.add_edge(1, 2)

#Add nodes
G.add_node('X')

#Create a list of edges instead. Remember edges are pairs of nodes.
temp_list = [('X', 'B'),('A', 'X'), (1, 'B')]
G.add_edges_from(temp_list)
G.add_nodes_from([3, 4, 5])
G.add_edge(2, 2)
G.number_of_nodes()
G.number_of_edges()

#selfloop is an edge that starts and ends at same node.
G.number_of_selfloops()

#Summary of network
#Degree= number of nodes to which a particular node is connected
print(nx.info(G))

#To figure out local clustering coefficient.
nx.average_clustering(Simple_Graph)

#Include latitutde and longitude information 
#(Tabitha is downloading a google package to map, 
#if that doesn't work, we can use distance formula for lat and long.

#Determine distance between the two nodes 
nx.all_simple_paths(Graph, Node1, Node2)
nx.shortest_path(Graph, Node1, Node2)
nx.shortest_path_length(Graph, Node1,
Node2)

****RECC#2 BASED ON USERS WITH SIMILAR TASTES: SIMILARITY. BIPARTITE GRAPH, DEGREE CENTRALITY, USING GLOBAL CLUSTERING COEFF.
#GLOBAL CLUSTERING COEFFICIENT
nx.average_clustering(Graph)

#using bipartite graph USERS VS COFFEE SHOPS

#determine degree centrality local cluStering coeffic

#Is this user strongly connected?? 
nx.is_strongly_connected(Graph)

#function to make recomendations based on similarity
def rec_teams(G, fan1, fan2):
    if G.node[fan1]['bipartite'] == G.node[fan2]['bipartite']:
        nbrs1 = G.neighbors(fan1)
        nbrs2 = G.neighbors(fan2)
        difference = set(nbrs1).difference(nbrs2)
        return difference
